#' @title Generate R Code for a Function which can Check a Result Data Frame
#' @description  well, exactly that
#' @param columns, the columns resulting from \code{create.columns} or
#'   \code{join.columns}
#' @param function.name the name of the function
#' @return a character array with the generated code
#' @include create_column.R
#' @include names.R
#' @export generate.result.data.frame.validate.function
generate.result.data.frame.validate.function <- function(columns,
                                                         function.name=.func.result.data.frame.validate) {
  stopifnot(is.character(function.name),
            length(function.name) == 1L,
            nchar(function.name) > 0L,
            !is.na(columns),
            is.list(columns),
            length(columns) == 3L);
  .check.columns(columns$columns, columns$conditions, columns$mergers);

  code <- c("#' @title Validate a Data Frame with Results",
            "#' @description Check whether all data in the frame \\code{x} is consistent.",
            "#' @param x the data frame",
            "#' @return either \\code{TRUE} or an error is thrown.",
            paste0(function.name, " <- function(x) {"));

  cond <- unlist(columns$conditions);
  l <- length(cond);
  if(l > 0L) {
    cond[[1L]] <- paste0("  stopifnot(", cond[[1L]]);
    cond[-1L] <- paste0("    ", cond[-1L]);
    cond[-l] <- paste0(cond[-l], ",");
    cond[[l]] <- paste0(cond[[l]], ");");
    code <- unlist(c(code, cond));
  }

  code <- unlist(c(code, "  return(TRUE);", "}"));

  p <- parse(text=paste(code, sep="\n", collapse="\n"));
  stopifnot(!is.null(p),
            is.expression(p));

  return(code);
}

#' @title Generate R Code for a Function which can Expand a Result Data Frame
#' @description  well, exactly that
#' @param columns, the columns resulting from \code{create.columns} or
#'   \code{join.columns}
#' @param function.name the name of the function
#' @param validate.function.name the name of the validation function
#' @return a character array with the generated code
#' @include create_column.R
#' @include names.R
#' @export generate.result.data.frame.expand.function
generate.result.data.frame.expand.function <- function(columns,
                                                       function.name=.func.result.data.frame.expand,
                                                       validate.function.name=.func.result.data.frame.validate) {
  stopifnot(is.character(function.name),
            length(function.name) == 1L,
            nchar(function.name) > 0L,
            is.character(validate.function.name),
            length(validate.function.name) == 1L,
            nchar(validate.function.name) > 0L,
            !is.na(columns),
            is.list(columns),
            length(columns) == 3L);
  .check.columns(columns$columns, columns$conditions, columns$mergers);

  code <- unname(unlist(c("#' @title Expand a Data Frame with Results",
            "#' @description Infer all data that can be infered from frame \\code{x} is and return the expanded frame.",
            "#' @param x the data frame",
            "#' @return the expanded data frame.",
            paste0(function.name, " <- function(x) {"),
            paste0("  while(", validate.function.name, "(x)) {"),
            "    changed <- FALSE;",
            paste0("    ", unname(unlist(columns$mergers))),
            "    if(!changed) {",
            .force("      ", "x"),
            "      return(x);",
            "    }",
            "  }",
            "}")));

  p <- parse(text=paste(code, sep="\n", collapse="\n"));
  stopifnot(!is.null(p),
            is.expression(p));

  return(code);
}

#' @title Generate a Function that can Load a Result Data Frame from a CSV File
#' @description Generate a loader function from a description of meta and result
#'   columns.
#' @param meta.columns the meta-data columns. Their value can either be
#'   specified as parameter of the generated function or inside the result csv
#'   file.
#' @param result.columns the values of these columns can only be specified in
#'   the csv file
#' @param function.name the function name to use for the generated function
#' @param validate.function.name the name of the function generated by
#'   \code{generate.result.data.frame.validate.function}
#' @param expand.function.name the name of the function generated by
#'   \code{generate.result.data.frame.expand.function}
#' @return a function for loading a data frame from a csv file
#' @export generate.result.data.frame.load
#' @include names.R
#' @include create_column.R
generate.result.data.frame.load <- function(meta.columns,
                                            result.columns,
                                            function.name=.func.result.data.frame.load,
                                            validate.function.name=.func.result.data.frame.validate,
                                            expand.function.name=.func.result.data.frame.expand) {

  stopifnot(is.character(function.name),
            length(function.name) == 1L,
            nchar(function.name) > 0L,
            is.character(validate.function.name),
            length(validate.function.name) == 1L,
            nchar(validate.function.name) > 0L,
            is.character(expand.function.name),
            length(expand.function.name) == 1L,
            nchar(expand.function.name) > 0L,
            !is.na(meta.columns),
            is.list(meta.columns),
            length(meta.columns) == 3L,
            !is.na(result.columns),
            is.list(result.columns),
            length(result.columns) == 3L);

  .check.columns(meta.columns$columns, meta.columns$conditions, meta.columns$mergers);
  .check.columns(stat.columns$columns, stat.columns$conditions, stat.columns$mergers);
  all.columns <- join.columns(meta.columns, stat.columns);

  .get.na <- function(xx) {
    if(xx$type %in% c("character", "integer", "real")) {
      return(paste0("NA_", xx$type, "_"));
    } else {
      if(xx$type == "double") {
        return("NA_real_");
      } else {
        if(xx$type == "logical") {
          return("NA");
        } else {
          stop(paste0("unknown type ", xx$type));
        }
      }
    }
  }

  code <-c("#' @title Load a Result Data Frame from a CSV-File",
           "#' @description Load a data frame from a CSV-File and fully expand it.",
           "#' @param file the path to the file to load",
           vapply(meta.columns$columns,
                  function(cc) {
                    paste0("#' @param ", cc$title, " ", cc$description)
                  }, ""),
           "#' @result the fully expanded data frame",
           paste(unlist(c(function.name,
                 " <- function(file",
                 vapply(meta.columns$columns,
                        function(cc) paste0(", ", cc$title, " = ", .get.na(cc)),
                        ""),
                 ") {")), sep="", collapse=""),
           "  file <- normalizePath(file, mustWork = TRUE);",
           "  stopifnot(file.exists(file),",
           "            file.size(file) > 0L);",
           "  frame <- read.csv(file=file, check.names = FALSE, stringsAsFactors = FALSE);",
           "  stopifnot(is.data.frame(frame), ",
           "            nrow(frame) > 0L,",
           "            ncol(frame) > 0L);",
           .force("  ", "frame"),
           paste(unlist(c("  permitted <- c(\"",
                          all.columns$columns[[1L]]$title,
                          "\"",
                          vapply(all.columns$columns[-1L],
                                 function(cc) paste0(", \"", cc$title, "\""), ""),
                          ");")), sep="", collapse=""),
           paste(unlist(c("  needed <- c(\"",
                          result.columns$columns[[1L]]$title,
                          "\"",
                          vapply(result.columns$columns[-1L],
                                 function(cc) paste0(", \"", cc$title, "\""), ""),
                          ");")), sep="", collapse=""),
           "  hasNeeded <- FALSE;",
           "  for(col in colnames(frame)) {",
           "    stopifnot(col %in% permitted);",
           "    if(col %in% needed) { hasNeeded <- TRUE; }",
           "  }",
           "  stopifnot(hasNeeded);",
           "  rows <- nrow(frame);",
           "  stopifnot(rows > 0L);",
           paste(unlist(c("  x <- data.frame(stringsAsFactors = FALSE, check.names=FALSE",
           unlist(vapply(meta.columns$columns,
                         function(cc) paste0(", as.", cc$type, "(rep_len(", cc$title, ", rows))"),
                         "")),
           unlist(vapply(result.columns$columns,
                         function(cc) paste0(", as.", cc$type, "(rep_len(", .get.na(cc), ", rows))"),
                         "")), ");")), sep="", collapse=""),
           "  hasNeeded <- FALSE;",
           "  for(col in colnames(frame)) {",
           "    cc <- unname(unlist(frame[col]));",
           "    stopifnot(any(!is.na(cc)), ",
           "              col %in% permitted);",
           "    if(col %in% needed) { hasNeeded <- TRUE; }",
           paste0("    x[col] <- cc;"),
           .force("    ", "x[col]", "x"),
           "  }",
           "  stopifnot(hasNeeded);",
           .force("    ", "x"),
           paste0("  ", validate.function.name, "(x);"),
           paste0("  x <- ", expand.function.name, "(x);"),
           .force("  ", "x"),
           paste0("  ", validate.function.name, "(x);"),
           "  return(x);",
           "}");

  p <- parse(text=paste(code, sep="\n", collapse="\n"));
  stopifnot(!is.null(p),
            is.expression(p));

  return(code);
}
